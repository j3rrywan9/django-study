# Django 3 By Example

## Chapter 1 Building a Blog Application

### Installing Django

#### Creating an isolated Python environment

#### Installing Django with pip

The `pip` package management system is the preferred method for installing Django.

### Creating your first project

The generated `settings.py` file contains the project settings, including a basic configuration to use an SQLite3 database and a list named `INSTALLED_APPS` that contains common Django applications that are added to your project by default.
We will go through these applications later in the *Project settings* section.

### Projects and applications

Throughout this book, you will encounter the terms **project** and **application** over and over.
In Django, a project is considered a Django installation with some settings.
An application is a group of models, views, templates, and URLs.
Applications interact with the framework to provide some specific functionalities and may be reused in various projects.

### Creating an application

### Running the development server

### Creating an administration site for models

Django comes with a built-in administration interface that is very useful for editing content.
The Django site is built dynamically by reading your model metadata and providing a production-ready interface for editing content.
You can use it out of the box, configuring how you want your models to be displayed in it.

#### Creating a superuser

#### The Django administration site

#### Adding models to the administration site

That was easy, right?
When you register a model in the Django administration site, you get a user-friendly interface generated by introspecting your models that allows you to list, edit, create, and delete objects in a simple way.

Django uses different form widgets for each type of field.

#### Customizing the way that models are displayed

You are telling the Django administration site that your model is registered in the site using a custom class that inherits from `ModelAdmin`.
In this class, you can include information about how to display the model in the site and how to interact with it.

The `list_display` attribute allows you to set the fields of your model that you want to display on the administration object list page.
The `@admin.register()` decorator performs the same function as the `admin.site.register()` function that you replaced, registering the `ModelAdmin` class that it decorates.

You can see that the fields displayed on the post list page are the ones you specified in the `list_display` attribute.
The list page now includes a right sidebar that allows you to filter the results by the fields included in the `list_filter` attribute.

A search bar has appeared on the page.
This is because you have defined a list of searchable fields using the `search_fields` attribute.
Just below the search bar, there are navigation links to navigate through a date hierarchy;
this has been defined by the `date_hierarchy` attribute.
You can also see that the posts are ordered by **STATUS** and **PUBLISH** columns by default.
You have specified the default sorting criteria using the `ordering` attribute.

### Working with QuerySet and managers

Django comes with a powerful database abstraction API that lets you create, retrieve, update, and delete objects easily.
The Django **object-relational mapper (ORM)** is compatible with MySQL, PostgreSQL, SQLite, Oracle, and MariaDB.
Remember that you can define the database of your project in the `DATABASES` setting of your project's `settings.py` file.
Django can work with multiple databases at a time, and you can program database routers to create custom routing schemes.

Once you have created your data models, Django gives you a free API to interact with them.

The Django ORM is based on QuerySets.
A QuerySet is a collection of database queries to retrieve objects from your database.
You can apply filters to QuerySets to narrow down the query results based on given parameters.

#### Creating objects

The `get()` method allows you to retrieve a single object from the database.
Note that this method expects a result that matches the query.
If no results are returned by the database, this method will raise a `DoesNotExist` exception, and if the database returns more than one result, it will raise a `MultipleObjectsReturned` exception.
Both exceptions are attributes of the model class that the query is being performed on.

#### Updating objects

#### Retrieving objects

You already know how to retrieve a single object from the database using the `get()` method.
You accessed this method using `Post.objects.get()`.
Each Django model has at least one manager, and the default manager is called `objects`.
You get a `QuerySet` object using your model manager.
To retrieve all objects from a table, you just use the `all()` method on the default objects manager, like this:
```python
all_posts = Post.objects.all()
```
This is how you create a QuerySet that returns all objects in the database.
Note that this QuerySet has not been executed yet.
Django QuerySets are *lazy*, which means they are only evaluated when they are forced to be.
This behavior makes QuerySets very efficient.

##### Using the `filter()` method

To filter a QuerySet, you can use the `filter()` method of the manager.
For example, you can retrieve all posts published in the year 2020 using the following QuerySet:
```python
Post.objects.filter(publish_year=2020)
```

##### Using `exclude()`

You can exclude certain results from your QuerySet using the `exclude()` method of the manager.

##### Using `order_by()`

You can order results by different fields using the `order_by()` method of the manager.

#### Deleting objects

#### When QuerySets are evaluated

Creating a QuerySet doesn't involve any database activity until it is evaluated.
QuerySets usually return another unevaluated QuerySet.
You can concatenate as many filters as you like to a QuerySet, and you will not hit the database until the QuerySet is evaluated.
When a QuerySet is evaluated, it translates into an SQL query to the database.

#### Creating model managers

### Building list and detail views

A Django view is just a Python function that receives a web request and returns a web response.
All the logic to return the desired response goes inside the view.

First, you will create your application views, then you will define a URL pattern for each view, and finally, you will create HTML templates to render the data generated by the views.
Each view will render a template, passing variables to it, and will return an HTTP response with the rendered output.

#### Creating list and detail views

Finally, you use the `render()` shortcut provided by Django to render the list of posts with the given template.
This function takes the `request` object, the template path, and the context variables to render the given template.
It returns an `HttpResponse` object with the rendered text (normally HTML code).
The `render()` shortcut takes the request context into account, so any variable set by the template context processors is accessible by the given template.
Template context processors are just callables that set variables into the context.

#### Adding URL patterns for your views

URL patterns allow you to map URLs to views.
A URL pattern is composed of a string pattern, a view, and, optionally, a name that allows you to name the URL project-wide.
Django runs through each URL pattern and stops at the first one that matches the requested URL.
Then, Django imports the view of the matching URL pattern and executes it, passing an instance of the `HttpRequest` class and the keyword or positional arguments.

Next, you have to include the URL patterns of the blog application in the main URL patterns of the project.

#### Canonical URLs for models

A canonical URL is the preferred URL for a resource.
You may have different pages in your site where you display posts, but there is a single URL that you use as the main URL for a blog post.
The convention in Django is to add a `get_absolute_url()` method to the model that returns the canonical URL for the object.

### Creating templates for your views

URL patterns map URLs to views, and views decide which data gets returned to the user.
Templates define how the data is displayed; they are usually written in HTML in combination with the Django template language.

Django has a powerful template language that allows you to specify how data is displayed.

### Adding pagination

### Using class-based views

Class-based views are an alternative way to implement views as Python objects instead of functions.
Since a view is a callable that takes a web request and returns a web response, you can also define your views as class methods.
Django provides base view classes for this.
All of them inherit from the `View` class, which handles HTTP method dispatching and other common functionalities.

## Chapter 2 Enhancing Your Blog with Advanced Features
